# sort
>代码测试，执行entry.cpp文件
## 一、基础排序
>代码实现见BaseSort
### 1、选择排序
- 基本思想

    将序列划分为已排序和未排序两部分，首先初始序列为未排序序列，已排序序列为空，从未排序的序列中查找最小或最大的元素，存放到排序序列的起始位置。
 然后再从剩余未排序列中继续寻找最小或最大的元素，放入已排序序列的尾部。以此类推，直到所有元素都完成排序。
> 二元选择排序方法，是简单选择排序的一种优化。在一次查找中，分别将最小和最大的元素查找出来，分别存放到序列队首和队尾的已排序序列的尾部。所以外层的循环次数变为n/2
- 动态图
![选择排序](./img/select.gif)
- 伪代码
```text
SELECTION-SORT(A)
   for j = 1 to Length(A)
       i = j
       key = A(i)
       for i to Lenth(A)
           if key>A(i)
                 key = A(i)
                 k = i
        A(k) = A(j)
        A(j)  = key
```
- 复杂度分析
> 平均时间复杂度：O(n^2) <br>
> 最佳时间复杂度：O(n^2) <br>
> 最差时间复杂度：O(n^2) <br>
> 空间复杂度：O(1) <br>
> 稳定性：不稳定

  总的比较次数为：(n-1) + (n-2) +…+ 1 = n x (n-1)/2，交换次数O(n)。最好情况是已有序，交换0次；最坏情况是逆序，交换n-1次。

### 2、归并排序
- 基本思想

    归并排序是采用分治思想，每次递归上有三个步骤：<br>
    a.**分解(Divide)**：将序列分为元素个数/2的子序列 <br>
    b.**解决(Conquer)**: 用合并排序法对两个子序列进行递归排序 <br>
    c.**合并(Merge)**: 合并两个已排序的子序列得到最终结果
> 有两种实现方式：<br>
> 自顶向下的实现是形成一个递归树，第一层长度为n的问题，下一层是上一层的n/2的子问题，逐层递减 <br>
> 自底向上的实现是序列被分成k个子序列，每个子序列元素个数为n/k，每份在用插入排序进行排序，然后对k个已排序的序列进行归并操作

- 动态图
![归并排序](./img/merge.gif)
- 伪代码
```text
MERGE(A,p,q,r)
n1 = q - p + 1
n2 = r - q
let L[1..n1+1] and R[1..n2+1] be new arrays
for i = 1 to n1
	L[i] = A[p + i -1]
for j = 1 to n2
	R[j] = A[q + j]
L[n1 + 1] = ∞
R[n2 + 1] = ∞
i = 1
j = 1
for k = p to r
	if L[i] <= R[j]
		A[k] = L[i]
		i = i + 1
	else 
		A[k] = R[j]
		j = j + 1
```
- 复杂度分析
> 平均时间复杂度：O(nlogn) <br>
> 最佳时间复杂度：O(nlogn) <br>
> 最差时间复杂度：O(nlogn) <br>
> 空间复杂度：O(n) <br>
> 稳定性：稳定

  不管元素是什么情况都需要执行这些操作，所以花销的时间不变，时间复杂度一样。空间复杂度是临时数组和递归时入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)。

### 3、快速排序
- 基本思想
  
  快速排序也是采用分治思想，先选择一个主元(pivot)，根据主元将序列分为两个子序列，将比主元大的数据放到它的右边，比主元小的数据放到它的左边。
  然后对两个子序列递归进行相同操作，直到序列中为空或只有一个元素为止。

> 三路快排是将序列分为小于主元序列，等于主元序列和大于主元序列，当等于主元部分元素非常多时，该算法越有优势。

- 动态图
![快速排序](./img/quick.gif)
- 伪代码
```text
QuickSort(A, p, r)
    if p < r
        q = Partition(A, p, r)
        QuickSort(A, p, q-1)
        QuickSort(Q, q+1, r)
end

Partition(A, p, r)
    x = A[r]
    i = p-1
    for j = p to r-1
        do if A[j] <= x
            then i = i+1
                exchange A[i] <-> A[j]
    exchange A[i+1] <-> A[r]
    return i+1
end
```
- 复杂度分析
> 平均时间复杂度：O(nlogn) <br>
> 最佳时间复杂度：O(nlogn) <br>
> 最差时间复杂度：O(n^2) <br>
> 空间复杂度： 不同情况空间复杂度不同<br>
> 稳定性：不稳定

最佳情况：每次都是均匀的划分，若排序序列中有n个元素，递归树的深度为logn, 根据递归树方法，则时间复杂度为O(nlogn),空间复杂度为O(nlogn)<br>
最坏情况：待排序序列为正序或者逆序，每次划分都有一个是空集，另一个为比上一个子序列少一个元素的子序列，比较次数为 $\sum_{i=1}^{n-1}$, 则时间复杂度为O(n^2),空间复杂度为O(n)


### 4、希尔排序
- 基本思想
  
  实质是分组的插入排序，先将整个待排序元素序列分成若干个组子序列，分别进行插入排序，然后修改分组的步长，待整个序列中元素基本有序时，再对整个序列进行一次排序
  >可使用交换法和位移法进行实现
- 动态图
![希尔排序](./img/shell.gif)
- 伪代码
```text
d = A.length / 2
while d > 0
    for i = 1 to d
        for j = i + d to A.length by d
            tmp = A[j]
            k = j - d
            while k > 0 and A[k] > tmp
                A[k + d] = A[k]
                k = k - d
            A[k + d] = tmp
    d = d / 2
```
- 复杂度分析
> 平均时间复杂度：O(nlogn) <br>
> 最佳时间复杂度：O(n) <br>
> 最差时间复杂度：O(n^2) <br>
> 空间复杂度： O(1)<br>
> 稳定性：不稳定

最佳情况：开始元素已排序
最坏情况：开始元素为逆序

### 5、基数排序
- 基本思想

  将整数按位数切割成不同的数字，然后按每个位的数字分别比较。
>实现方式可分为从高位到低位进行排序(MSD)，可采用计数排序；从低位到高位进行排序(LSD)，可采用桶排序

- 动态图
![基数排序](./img/radix.gif)

- 伪代码
```text
RADIX_SORT(A, d)
    for i <- 1 to d
        do use a stable sort to sort array A on digit i
```
- 复杂度分析
> 平均时间复杂度：O(k*n) <br>
> 空间复杂度： O(k+n)<br>
> 稳定性：稳定

设待排序的数组A[1..n]，数组中最大的数是d位数，基数为r。
处理一位数，需要将数组元素映射到r个桶中，映射完成后还需要收集，相当于遍历数组一遍，最多元素数为n，则时间复杂度为O(n+r)。<br>
排序过程中，用到一个计数器数组，长度为r，还用到一个rn的二位数组来做为桶，所以空间复杂度为O(rn)。

### 性能分析
分别以n=1000, 5000, 10000, 50000, 80000, 100000不同规模重复5次进行测试，测试结果如下（耗时以秒为单位）：


| 规模     | 选择排序 | 二元选择排序 | 归并排序_递归法 | 归并排序_迭代法 | 快速排序 | 三路快速排序 | 希尔排序_移位法 | 希尔排序_交换法 | 基数排序_计数   | 基数排序_桶 |
|--------| ----  | -------- | ---------- | ----------- | ----- | -------|-----------|  ---------  |-----------| ------- |
| 1000   | 0.0029 | 0.0025 | 0.0003 | 0.0002 | 0.0001 | 0.0002 | 0.0003 | 0.0027 | 0.0001 | 0.0008 |
| 5000   | 0.0328 | 0.0311 | 0.0016 | 0.0010 | 0.0009 | 0.0013 | 0.0017 | 0.0663 | 0.0005 | 0.0032 |
| 10000  | 0.1196 | 0.1130 | 0.0028 | 0.0019 | 0.0017 | 0.0024 | 0.0030 | 0.2615 | 0.0008 | 0.0048 |
| 50000  | 2.9742 | 2.7313 | 0.0107 | 0.0094 | 0.0075 | 0.0093 | 0.0140 | 5.6069 | 0.0034 | 0.0184 |
| 80000  | 7.5878 | 7.0878 | 0.0145 | 0.0144 | 0.0101 | 0.0123 | 0.0217 | 16.897 | 0.0043 | 0.0297 |
| 100000 | 11.863 | 11.121 | 0.0185 | 0.0189 | 0.0127 | 0.0152 | 0.0283 | 22.502 | 0.0045 | 0.0363 |

## 三、分布式排序

>代码实现见DistributedSort

### SyncSort

本方法提供同步分布式排序，调用本方法后会将待排序数据分成10份，每份单独在一个线程上执行排序，排序方法分别采用BaseSort中的10种排序方法，排序过程中会阻塞主线程，直到排序完成。

### AsyncSort

本方法提供异步分布式排序，排序过程同SyncSort，但不会阻塞主线程。